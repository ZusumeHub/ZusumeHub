-- ZusumeHub Script for Roblox
-- Original Author: Zysume
-- Version: 1.0
-- Last Updated: April 2025
-- Description: A comprehensive script for autofarming, teleportation, and combat enhancements in Roblox games.

-- Services
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local VirtualInputManager = game:GetService("VirtualInputManager")
local StarterGui = game:GetService("StarterGui")

-- Fetch and Load the Library
local libraryUrl = "https://raw.githubusercontent.com/ZusumeHub/ZusumeHub/refs/heads/main/LibraryNewUI"
local success, libraryCode = pcall(function()
    return game:HttpGet(libraryUrl)
end)

if not success then
    warn("Failed to fetch the library: " .. tostring(libraryCode))
    return
end

local TeleportGUILibrary
success, TeleportGUILibrary = pcall(function()
    return loadstring(libraryCode)()
end)

if not success or not TeleportGUILibrary then
    warn("Failed to load the library: " .. tostring(TeleportGUILibrary))
    return
end

local ContentFrame = TeleportGUILibrary.ContentFrame
if not ContentFrame then
    warn("ContentFrame not found in the library")
    return
end

-- Variables for Autofarming and Combat Features
local wallhackActive = false
local wallhackConnection = nil

local isAutoFloorActive = false
local currentTargetMob2 = nil
local autoFloorLoop = nil
local lastNotificationTime2 = 0
local teleportedToCurrentMob2 = false
local sizeModified2 = false
local autoHarvestRunning = false
local autoHarvestConnection = nil
local autoFloorCheckbox = nil
local isDeathProcessing = false

local isAutofarming = false
local currentTargetMob = nil
local autofarmLoop = nil
local lastNotificationTime = 0
local teleportedToCurrentMob = false
local sizeModified = false

local isSuppliesAutofarming = false
local suppliesAutofarmLoop = nil

local targetFoundTime = 0
local targetDelaySeconds = 0.5

local isTeleportStoryActive = false
local teleportStoryConnection = nil

local walkSpeedValue = 32
local walkSpeedInput = nil

local jumpHeightValue = 7.2 -- Default JumpHeight (Roblox default is approximately 7.2 studs)
local jumpHeightInput = nil

local flyingPlatformValue = 2 -- Default HumanoidRootPart.Size.Y
local flyingPlatformInput = nil
local flyingPlatformAdjusting = false

-- Utility Functions
-- Function to simulate a key press
local function pressKey(keyCode)
    VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
    wait(0.1)
    VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
end

-- Function to find drop parts with proximity prompts
local function findDropPartsWithPrompts()
    local dropParts = {}
    local dropFolder = workspace:FindFirstChild("Drop")
    if dropFolder and dropFolder:IsA("Folder") then
        for _, child in pairs(dropFolder:GetChildren()) do
            if child:IsA("BasePart") and child.Name ~= "Drop" then
                local proximityPrompt = child:FindFirstChild("ProximityPrompt")
                if proximityPrompt then
                    table.insert(dropParts, child)
                end
            end
        end
    end
    return dropParts
end

-- Function to fire a proximity prompt with retry logic
local function enhancedFireProximityPrompt(prompt, attempts)
    attempts = attempts or 3
    local promptPart = prompt.Parent
    local character = LocalPlayer.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart or not promptPart then
        return
    end
    humanoidRootPart.CFrame = CFrame.new(promptPart.Position + Vector3.new(0, 1, 0))
    wait(0.5)
    for i = 1, attempts do
        fireproximityprompt(prompt)
        TeleportGUILibrary.createNotification("Firing prompt attempt " .. i, "info")
        wait(0.5)
    end
    wait(1)
end

-- Function to teleport to a part and interact with its proximity prompt
local function teleportAndStickToPrompt(part)
    local character = LocalPlayer.Character
    if not character then
        return false
    end
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then
        return false
    end
    local proximityPrompt = part:FindFirstChild("ProximityPrompt")
    if not proximityPrompt then
        return false
    end
    humanoidRootPart.CFrame = CFrame.new(part.Position + Vector3.new(0, 2, 0))
    wait(0.5)
    enhancedFireProximityPrompt(proximityPrompt)
    return true
end

-- Function to find the nearest mob within a radius
local function findNearestMob(radius, maxDistance)
    local character = LocalPlayer.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then
        return nil
    end
    local nearestMob = nil
    local shortestDistance = maxDistance or radius
    local unitsFolder = workspace:FindFirstChild("Units")
    if unitsFolder then
        for _, unit in pairs(unitsFolder:GetChildren()) do
            local model = unit:FindFirstChild("MODEL")
            if model then
                local mobRootPart = model:FindFirstChild("HumanoidRootPart")
                if mobRootPart then
                    local hp = unit:GetAttribute("HP")
                    if hp and hp > 0 then
                        local distance = (humanoidRootPart.Position - mobRootPart.Position).Magnitude
                        if distance < shortestDistance then
                            shortestDistance = distance
                            nearestMob = unit
                        end
                    end
                end
            end
        end
    end
    return nearestMob
end

-- Function to incrementally increase the size of the HumanoidRootPart
local function incrementHumanoidRootPartSize(humanoidRootPart, maxHeight)
    local originalSize = Vector3.new(2, 2, 1)
    humanoidRootPart.Size = Vector3.new(originalSize.X, 2, originalSize.Z)
    spawn(function()
        for i = 3, maxHeight do
            wait(0.3)
            if humanoidRootPart and humanoidRootPart.Parent then
                humanoidRootPart.Size = Vector3.new(originalSize.X, i, originalSize.Z)
            else
                break
            end
        end
    end)
end

-- Function to incrementally adjust HumanoidRootPart.Size.Y for Flying Platform
local function adjustFlyingPlatformHeight(humanoidRootPart, targetHeight)
    flyingPlatformAdjusting = true
    local originalSize = humanoidRootPart.Size
    local currentY = originalSize.Y
    local step = currentY < targetHeight and 0.5 or -0.5
    local stepsNeeded = math.abs(targetHeight - currentY) / math.abs(step)
    local stepCount = 0
    while stepCount < stepsNeeded do
        if not humanoidRootPart or not humanoidRootPart.Parent then
            flyingPlatformAdjusting = false
            return
        end
        currentY = currentY + step
        humanoidRootPart.Size = Vector3.new(originalSize.X, currentY, originalSize.Z)
        wait(0.2)
        stepCount = stepCount + 1
    end
    -- Set to exact target height to avoid floating-point errors
    humanoidRootPart.Size = Vector3.new(originalSize.X, targetHeight, originalSize.Z)
    flyingPlatformAdjusting = false
end

-- Function to reset the HumanoidRootPart size to default
local function resetHumanoidRootPartSize()
    local character = LocalPlayer.Character
    if character then
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            humanoidRootPart.Size = Vector3.new(2, 2, 1)
            flyingPlatformValue = 2
            if flyingPlatformInput then
                flyingPlatformInput.setValue(2)
            end
        end
    end
end

-- Function to enable wallhack (noclip)
local function enableWallhack()
    if wallhackConnection then
        return
    end
    wallhackActive = true
    wallhackConnection = RunService.Stepped:Connect(function()
        if not wallhackActive then
            if wallhackConnection then
                wallhackConnection:Disconnect()
                wallhackConnection = nil
            end
            return
        end
        local character = LocalPlayer.Character
        if character then
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end)
    TeleportGUILibrary.createNotification("Wallhack enabled", "success")
end

-- Function to disable wallhack (restore collision)
local function disableWallhack()
    wallhackActive = false
    if wallhackConnection then
        wallhackConnection:Disconnect()
        wallhackConnection = nil
    end
    local character = LocalPlayer.Character
    if character then
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                part.CanCollide = true
            end
        end
    end
    TeleportGUILibrary.createNotification("Wallhack disabled", "warning")
end

-- Function to tween the player to a position
local function tweenToPosition(position, duration)
    local character = LocalPlayer.Character
    if not character then
        return
    end
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then
        return
    end
    local tweenInfo = TweenInfo.new(duration or 1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local tween = TweenService:Create(humanoidRootPart, tweenInfo, {CFrame = CFrame.new(position)})
    tween:Play()
    return tween
end

-- Function to start the DrugStore dungeon (initial teleport)
local function startDrugStoreDungeonFirst()
    local args = {
        [1] = {
            CF = CFrame.new(2177.754638671875, -196.92501831054688, 196.78997802734375) * CFrame.Angles(0, 0, 0),
            Type = "SyncCF"
        }
    }
    game:GetService("ReplicatedStorage").Remote.CharacterRE:FireServer(unpack(args))
    TeleportGUILibrary.createNotification("Preparing DrugStore dungeon", "info")
end

-- Function to start the DrugStore dungeon
local function startDrugStoreDungeon()
    local args = {
        [1] = {
            ID = "T1DrugStore",
            Type = "Start",
            Diff = 1
        }
    }
    game:GetService("ReplicatedStorage").Remote.DungeonRE:FireServer(unpack(args))
    TeleportGUILibrary.createNotification("Started DrugStore dungeon", "info")
end

-- Function to start autofarming supplies
local function startSuppliesAutofarm()
    if suppliesAutofarmLoop then
        return
    end
    isSuppliesAutofarming = true
    enableWallhack()
    startDrugStoreDungeonFirst()
    wait(2)
    startDrugStoreDungeon()
    suppliesAutofarmLoop = coroutine.create(function()
        while isSuppliesAutofarming do
            local dropParts = findDropPartsWithPrompts()
            if #dropParts > 0 then
                TeleportGUILibrary.createNotification("Found " .. #dropParts .. " supply items to collect", "info")
                for i, part in ipairs(dropParts) do
                    if not isSuppliesAutofarming then
                        break
                    end
                    TeleportGUILibrary.createNotification("Collecting supply: " .. part.Name, "info")
                    local success = teleportAndStickToPrompt(part)
                    TeleportGUILibrary.createNotification(
                        success and "Successfully interacted with: " .. part.Name or "Failed to interact with: " .. part.Name,
                        success and "success" or "error"
                    )
                    wait(1)
                end
                TeleportGUILibrary.createNotification("Completed supply collection cycle", "success")
            else
                TeleportGUILibrary.createNotification("No supply items found to collect", "warning")
                startDrugStoreDungeon()
            end
            wait(3)
        end
    end)
    coroutine.resume(suppliesAutofarmLoop)
end

-- Function to stop autofarming supplies
local function stopSuppliesAutofarm()
    isSuppliesAutofarming = false
    suppliesAutofarmLoop = nil
    disableWallhack()
    TeleportGUILibrary.createNotification("Autofarm Supplies stopped", "warning")
end

-- Function to start autofarming nearest mobs
local function startAutofarm()
    if autofarmLoop then
        return
    end
    isAutofarming = true
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    autofarmLoop = RunService.Heartbeat:Connect(function()
        if not isAutofarming then
            if autofarmLoop then
                autofarmLoop:Disconnect()
                autofarmLoop = nil
            end
            resetHumanoidRootPartSize()
            return
        end
        if currentTargetMob then
            local model = currentTargetMob:FindFirstChild("MODEL")
            if not model or not model:FindFirstChild("HumanoidRootPart") then
                currentTargetMob = nil
                teleportedToCurrentMob = false
                TeleportGUILibrary.createNotification("Target defeated, finding new target", "info")
                return
            end
            local hp = currentTargetMob:GetAttribute("HP")
            if not hp or hp < 1 then
                currentTargetMob = nil
                teleportedToCurrentMob = false
                TeleportGUILibrary.createNotification("Target defeated, finding new target", "info")
                return
            end
            if not teleportedToCurrentMob then
                local mobPosition = currentTargetMob.MODEL.HumanoidRootPart.Position
                humanoidRootPart.CFrame = CFrame.new(Vector3.new(mobPosition.X, mobPosition.Y + 5, mobPosition.Z))
                teleportedToCurrentMob = true
                if sizeModified and humanoidRootPart.Size.Y < 10 then
                    incrementHumanoidRootPartSize(humanoidRootPart, 10)
                end
                return
            end
        else
            local nearestMob = findNearestMob(15, 15)
            if nearestMob then
                currentTargetMob = nearestMob
                teleportedToCurrentMob = false
                if not sizeModified then
                    incrementHumanoidRootPartSize(humanoidRootPart, 10)
                    sizeModified = true
                end
                TeleportGUILibrary.createNotification("Found new target: " .. nearestMob.Name, "info")
            else
                local currentTime = os.time()
                if currentTime - lastNotificationTime >= 5 then
                    TeleportGUILibrary.createNotification("No targets found nearby", "warning")
                    lastNotificationTime = currentTime
                end
            end
        end
    end)
end

-- Function to stop autofarming nearest mobs
local function stopAutofarm()
    isAutofarming = false
    currentTargetMob = nil
    teleportedToCurrentMob = false
    sizeModified = false
    if autofarmLoop then
        autofarmLoop:Disconnect()
        autofarmLoop = nil
    end
    resetHumanoidRootPartSize()
    TeleportGUILibrary.createNotification("Autofarm stopped", "warning")
end

-- Function to start Auto Floor (Original Implementation)
local function startAutoFloor()
    if autoFloorLoop then
        return
    end
    isAutoFloorActive = true
    autoHarvestRunning = true
    -- Activate InfExplore
    local args = {
        [1] = {
            T = "InfExplore"
        }
    }
    game:GetService("ReplicatedStorage").Remote.ExploreRE:FireServer(unpack(args))
    TeleportGUILibrary.createNotification("Activated InfExplore", "info")
    wait(2)
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    local lastTargetTime = os.time()
    -- Notify user that Auto Harvest is activated with Auto Floor
    StarterGui:SetCore("SendNotification", {
        Title = "Auto Harvest",
        Text = "Auto Harvest activated with Auto Floor!",
        Duration = 5
    })
    -- Start auto harvest loop
    autoHarvestConnection = RunService.Heartbeat:Connect(function()
        if not autoHarvestRunning or not isAutoFloorActive or isDeathProcessing then
            if autoHarvestConnection then
                autoHarvestConnection:Disconnect()
                autoHarvestConnection = nil
            end
            return
        end
        local hasTarget = currentTargetMob2 and currentTargetMob2:FindFirstChild("MODEL") and currentTargetMob2.MODEL:FindFirstChild("HumanoidRootPart")
        if hasTarget then
            local hp = currentTargetMob2:GetAttribute("HP")
            hasTarget = hp and hp > 0
        end
        if hasTarget then
            pressKey(Enum.KeyCode.F)
            wait(0.2)
        else
            pressKey(Enum.KeyCode.F)
            wait(1)
            pressKey(Enum.KeyCode.E)
            wait(2)
        end
    end)
    -- Start auto floor loop
    autoFloorLoop = RunService.Heartbeat:Connect(function()
        if not isAutoFloorActive then
            if autoFloorLoop then
                autoFloorLoop:Disconnect()
                autoFloorLoop = nil
            end
            if autoHarvestConnection then
                autoHarvestConnection:Disconnect()
                autoHarvestConnection = nil
                autoHarvestRunning = false
                StarterGui:SetCore("SendNotification", {
                    Title = "Auto Harvest",
                    Text = "Auto Harvest stopped with Auto Floor!",
                    Duration = 5
                })
            end
            resetHumanoidRootPartSize()
            return
        end
        if currentTargetMob2 then
            lastTargetTime = os.time()
            local model = currentTargetMob2:FindFirstChild("MODEL")
            if not model or not model:FindFirstChild("HumanoidRootPart") then
                currentTargetMob2 = nil
                teleportedToCurrentMob2 = false
                TeleportGUILibrary.createNotification("Target defeated, finding new target", "info")
                return
            end
            local hp = currentTargetMob2:GetAttribute("HP")
            if not hp or hp < 1 then
                currentTargetMob2 = nil
                teleportedToCurrentMob2 = false
                TeleportGUILibrary.createNotification("Target defeated, finding new target", "info")
                return
            end
            local currentTime = os.time()
            local timeElapsedSinceFound = currentTime - targetFoundTime
            if not teleportedToCurrentMob2 and timeElapsedSinceFound >= targetDelaySeconds then
                local mobPosition = currentTargetMob2.MODEL.HumanoidRootPart.Position
                humanoidRootPart.CFrame = CFrame.new(Vector3.new(mobPosition.X, mobPosition.Y + 20, mobPosition.Z))
                teleportedToCurrentMob2 = true
                if sizeModified2 and humanoidRootPart.Size.Y < 35 then
                    incrementHumanoidRootPartSize(humanoidRootPart, 35)
                end
                TeleportGUILibrary.createNotification("Teleported to target after delay", "success")
                return
            elseif not teleportedToCurrentMob2 and timeElapsedSinceFound < targetDelaySeconds then
                local remainingTime = targetDelaySeconds - timeElapsedSinceFound
                if math.floor(remainingTime) ~= math.floor(remainingTime + 0.1) then
                    TeleportGUILibrary.createNotification("Waiting " .. math.ceil(remainingTime) .. " seconds before teleporting", "info")
                end
                return
            end
            return
        end
        local nearestMob = findNearestMob(80, 80)
        if nearestMob then
            currentTargetMob2 = nearestMob
            teleportedToCurrentMob2 = false
            lastTargetTime = os.time()
            targetFoundTime = os.time()
            if not sizeModified2 then
                incrementHumanoidRootPartSize(humanoidRootPart, 20)
                sizeModified2 = true
            end
            TeleportGUILibrary.createNotification(
                "Found new target: " .. nearestMob.Name .. ". Waiting " .. targetDelaySeconds .. " seconds before teleporting",
                "info"
            )
        else
            local currentTime = os.time()
            local timeWithoutTarget = currentTime - lastTargetTime
            if timeWithoutTarget >= 3 and sizeModified2 then
                resetHumanoidRootPartSize()
                sizeModified2 = false
                TeleportGUILibrary.createNotification("Reset character size - no targets found for 3 seconds", "warning")
            end
            if currentTime - lastNotificationTime2 >= 5 then
                TeleportGUILibrary.createNotification("No targets found nearby", "warning")
                lastNotificationTime2 = currentTime
            end
        end
    end)
end

-- Function to stop Auto Floor
local function stopAutoFloor()
    isAutoFloorActive = false
    currentTargetMob2 = nil
    teleportedToCurrentMob2 = false
    sizeModified2 = false
    if autoFloorLoop then
        autoFloorLoop:Disconnect()
        autoFloorLoop = nil
    end
    if autoHarvestConnection then
        autoHarvestConnection:Disconnect()
        autoHarvestConnection = nil
        autoHarvestRunning = false
        StarterGui:SetCore("SendNotification", {
            Title = "Auto Harvest",
            Text = "Auto Harvest stopped with Auto Floor!",
            Duration = 5
        })
    end
    resetHumanoidRootPartSize()
    if autoFloorCheckbox then
        autoFloorCheckbox:SetState(false)
    end
    TeleportGUILibrary.createNotification("Auto Floor stopped", "warning")
end

-- Function to start Teleport Next Story
local function startTeleportStory()
    if teleportStoryConnection then
        return
    end
    isTeleportStoryActive = true
    local storyPrompt = workspace:FindFirstChild("StoryPromptREMOTE")
    if not storyPrompt then
        TeleportGUILibrary.createNotification("StoryPromptREMOTE not found!", "error")
        isTeleportStoryActive = false
        return
    end
    local cframe = storyPrompt.CFrame
    if not cframe then
        TeleportGUILibrary.createNotification("No CFrame found in StoryPromptREMOTE!", "error")
        isTeleportStoryActive = false
        return
    end
    teleportStoryConnection = RunService.Heartbeat:Connect(function()
        if not isTeleportStoryActive then
            if teleportStoryConnection then
                teleportStoryConnection:Disconnect()
                teleportStoryConnection = nil
            end
            return
        end
        local character = LocalPlayer.Character
        if not character then
            return
        end
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if not humanoidRootPart then
            return
        end
        humanoidRootPart.CFrame = cframe + Vector3.new(0, 2, 0) -- Offset slightly above to avoid clipping
        TeleportGUILibrary.createNotification("Teleported to StoryPromptREMOTE position", "success")
        wait(1) -- Prevent excessive teleportation in the loop
    end)
end

-- Function to stop Teleport Next Story
local function stopTeleportStory()
    isTeleportStoryActive = false
    if teleportStoryConnection then
        teleportStoryConnection:Disconnect()
        teleportStoryConnection = nil
    end
    TeleportGUILibrary.createNotification("Teleport Next Story stopped", "warning")
end

-- Function to apply WalkSpeed with limits
local function applyWalkSpeed(speed)
    local character = LocalPlayer.Character
    if character then
        local humanoid = character:FindFirstChild("Humanoid")
        if humanoid then
            -- Apply limits: 0 to 999
            if speed < 0 then
                speed = 0
                TeleportGUILibrary.createNotification("WalkSpeed cannot be less than 0!", "error")
            elseif speed > 999 then
                speed = 999
                TeleportGUILibrary.createNotification("WalkSpeed cannot be more than 999!", "error")
            end
            humanoid.WalkSpeed = speed
            walkSpeedValue = speed
            if walkSpeedInput banter
                walkSpeedInput.setValue(speed)
            end
            TeleportGUILibrary.createNotification("WalkSpeed set to " .. speed, "success")
        end
    end
end

-- Function to apply JumpHeight with limits
local function applyJumpHeight(height)
    local character = LocalPlayer.Character
    if character then
        local humanoid = character:FindFirstChild("Humanoid")
        if humanoid then
            -- Apply limits: 0 to 999
            if height < 0 then
                height = 0
                TeleportGUILibrary.createNotification("Jump Height cannot be less than 0!", "error")
            elseif height > 999 then
                height = 999
                TeleportGUILibrary.createNotification("Jump Height cannot be more than 999!", "error")
            end
            humanoid.JumpHeight = height
            jumpHeightValue = height
            if jumpHeightInput then
                jumpHeightInput.setValue(height)
            end
            TeleportGUILibrary.createNotification("Jump Height set to " .. height, "success")
        end
    end
end

-- Function to apply Flying Platform height with limits
local function applyFlyingPlatformHeight(height)
    local character = LocalPlayer.Character
    if character then
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            -- Apply limits: 0 to 999
            if height < 0 then
                height = 0
                TeleportGUILibrary.createNotification("Flying Platform height cannot be less than 0!", "error")
            elseif height > 999 then
                height = 999
                TeleportGUILibrary.createNotification("Flying Platform height cannot be more than 999!", "error")
            end
            adjustFlyingPlatformHeight(humanoidRootPart, height)
            flyingPlatformValue = height
            if flyingPlatformInput then
                flyingPlatformInput.setValue(height)
            end
            TeleportGUILibrary.createNotification("Flying Platform height set to " .. height, "success")
        end
    end
end

-- Create the UI Elements
-- Section: Teleportation Options
local teleportLabel, teleportSeparator = TeleportGUILibrary.createSection("MAIN HACKS", 5)

-- Checkbox: Autofarm Nearest
local autofarmCheckbox, getAutofarmState
autofarmCheckbox, getAutofarmState = TeleportGUILibrary.createCheckbox(
    "AutofarmCheckbox",
    "Autofarm Nearest",
    UDim2.new(0.05, 0, 0, 40),
    ContentFrame,
    function(checked)
        isAutofarming = checked
        if checked then
            TeleportGUILibrary.createNotification("Autofarm Nearest enabled!", "success")
            startAutofarm()
        else
            TeleportGUILibrary.createNotification("Autofarm Nearest disabled!", "warning")
            stopAutofarm()
        end
    end
)

-- Checkbox: Autofarm Supplies [OP]
local suppliesAutofarmCheckbox, getSuppliesAutofarmState
suppliesAutofarmCheckbox, getSuppliesAutofarmState = TeleportGUILibrary.createCheckbox(
    "SuppliesAutofarmCheckbox",
    "Autofarm Supplies [OP]",
    UDim2.new(0.05, 0, 0, 70),
    ContentFrame,
    function(checked)
        isSuppliesAutofarming = checked
        if checked then
            TeleportGUILibrary.createNotification("Autofarm Supplies [OP] enabled!", "success")
            startSuppliesAutofarm()
        else
            TeleportGUILibrary.createNotification("Autofarm Supplies [OP] disabled!", "warning")
            stopSuppliesAutofarm()
        end
    end
)

-- Checkbox: Auto Floor
local getAutoFloorState
autoFloorCheckbox, getAutoFloorState = TeleportGUILibrary.createCheckbox(
    "AutoFloorCheckbox",
    "Auto Floor",
    UDim2.new(0.05, 0, 0, 100),
    ContentFrame,
    function(checked)
        isAutoFloorActive = checked
        if checked then
            TeleportGUILibrary.createNotification("Auto Floor enabled!", "success")
            startAutoFloor()
        else
            TeleportGUILibrary.createNotification("Auto Floor disabled!", "warning")
            stopAutoFloor()
        end
    end
)

-- Checkbox: Teleport Next Story
local teleportStoryCheckbox, getTeleportStoryState
teleportStoryCheckbox, getTeleportStoryState = TeleportGUILibrary.createCheckbox(
    "TeleportStoryCheckbox",
    "Teleport Next Story",
    UDim2.new(0.05, 0, 0, 130),
    ContentFrame,
    function(checked)
        isTeleportStoryActive = checked
        if checked then
            TeleportGUILibrary.createNotification("Teleport Next Story enabled!", "success")
            startTeleportStory()
        else
            TeleportGUILibrary.createNotification("Teleport Next Story disabled!", "warning")
            stopTeleportStory()
        end
    end
)

-- Section: Combat Options
local combatLabel, combatSeparator = TeleportGUILibrary.createSection("PLAYER SETTING", 165)

-- Text Input: WalkSpeed
local walkSpeedContainer
walkSpeedContainer, walkSpeedInput = TeleportGUILibrary.createTextInput(
    "WalkSpeedInput",
    "WalkSpeed",
    walkSpeedValue,
    UDim2.new(0.05, 0, 0, 195),
    ContentFrame,
    function(value)
        local speed = tonumber(value)
        if speed then
            applyWalkSpeed(speed)
        else
            TeleportGUILibrary.createNotification("Invalid WalkSpeed value! Please enter a number.", "error")
            walkSpeedInput.setValue(walkSpeedValue) -- Revert to the last valid value
        end
    end
)

-- Text Input: Jump Height
local jumpHeightContainer
jumpHeightContainer, jumpHeightInput = TeleportGUILibrary.createTextInput(
    "JumpHeightInput",
    "Jump Height",
    jumpHeightValue,
    UDim2.new(0.05, 0, 0, 225),
    ContentFrame,
    function(value)
        local height = tonumber(value)
        if height then
            applyJumpHeight(height)
        else
            TeleportGUILibrary.createNotification("Invalid Jump Height value! Please enter a number.", "error")
            jumpHeightInput.setValue(jumpHeightValue) -- Revert to the last valid value
        end
    end
)

-- Text Input: Flying Platform
local flyingPlatformContainer
flyingPlatformContainer, flyingPlatformInput = TeleportGUILibrary.createTextInput(
    "FlyingPlatformInput",
    "Flying Platform",
    flyingPlatformValue,
    UDim2.new(0.05, 0, 0, 255),
    ContentFrame,
    function(value)
        local height = tonumber(value)
        if height then
            applyFlyingPlatformHeight(height)
        else
            TeleportGUILibrary.createNotification("Invalid Flying Platform value! Please enter a number.", "error")
            flyingPlatformInput.setValue(flyingPlatformValue) -- Revert to the last valid value
        end
    end
)

-- Checkbox: Enable Wallhack (NoClip)
local wallhackCheckbox, getWallhackState
wallhackCheckbox, getWallhackState = TeleportGUILibrary.createCheckbox(
    "WallhackCheckbox",
    "Wallhack",
    UDim2.new(0.05, 0, 0, 285),
    ContentFrame,
    function(checked)
        if checked then
            enableWallhack()
        else
            disableWallhack()
        end
    end
)

-- Update Canvas Size
TeleportGUILibrary.updateCanvasSize(315)

-- Function to monitor the death indicator and handle respawn
local function monitorDeathIndicator()
    local playerGui = LocalPlayer:WaitForChild("PlayerGui")
    local screenInfExpResult = playerGui:WaitForChild("ScreenInfExpResult")
    local frame = screenInfExpResult:WaitForChild("Frame")
    local lastVisibleState = frame.Visible
    local visibleConnection
    visibleConnection = frame:GetPropertyChangedSignal("Visible"):Connect(function()
        if frame.Visible and not lastVisibleState and isAutoFloorActive then
            TeleportGUILibrary.createNotification("Player died, restarting Auto Floor!", "warning")
            isDeathProcessing = true
            if autoFloorLoop then
                autoFloorLoop:Disconnect()
                autoFloorLoop = nil
            end
            if autoHarvestConnection then
                autoHarvestConnection:Disconnect()
                autoHarvestConnection = nil
                autoHarvestRunning = false
            end
            resetHumanoidRootPartSize()
            wait(5)
            pressKey(Enum.KeyCode.E)
            TeleportGUILibrary.createNotification("Pressed E key after 5-second delay", "info")
            wait(2)
            local args = {
                [1] = {
                    T = "InfExplore"
                }
            }
            game:GetService("ReplicatedStorage").Remote.ExploreRE:FireServer(unpack(args))
            TeleportGUILibrary.createNotification("Reactivated InfExplore after 2-second delay", "info")
            isDeathProcessing = false
            startAutoFloor()
        end
        lastVisibleState = frame.Visible
    end)
    playerGui.AncestryChanged:Connect(function()
        if not playerGui.Parent and visibleConnection then
            visibleConnection:Disconnect()
            visibleConnection = nil
        end
    end)
end

-- Character Event Handlers
if LocalPlayer.Character then
    local character = LocalPlayer.Character
    local humanoid = character:FindFirstChild("Humanoid")
    if humanoid then
        humanoid.Died:Connect(function()
            stopAutofarm()
            stopSuppliesAutofarm()
            disableWallhack()
            stopTeleportStory()
        end)
        applyWalkSpeed(walkSpeedValue)
        applyJumpHeight(jumpHeightValue)
        applyFlyingPlatformHeight(flyingPlatformValue)
    end
end

LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    local humanoid = newCharacter:WaitForChild("Humanoid")
    humanoid.Died:Connect(function()
        stopAutofarm()
        stopSuppliesAutofarm()
        disableWallhack()
        stopTeleportStory()
    end)
    humanoid.WalkSpeed = walkSpeedValue
    humanoid.JumpHeight = jumpHeightValue
    TeleportGUILibrary.createNotification("WalkSpeed restored to " .. walkSpeedValue .. " on respawn", "info")
    TeleportGUILibrary.createNotification("Jump Height restored to " .. jumpHeightValue .. " on respawn", "info")
    local humanoidRootPart = newCharacter:WaitForChild("HumanoidRootPart")
    applyFlyingPlatformHeight(flyingPlatformValue)
    wait(1)
    if isAutofarming then
        if sizeModified then
            incrementHumanoidRootPartSize(humanoidRootPart, 10)
        end
        teleportedToCurrentMob = false
    end
    if isAutoFloorActive then
        if sizeModified2 then
            incrementHumanoidRootPartSize(humanoidRootPart, 20)
        end
        teleportedToCurrentMob2 = false
        if not autoHarvestConnection then
            autoHarvestRunning = true
            autoHarvestConnection = RunService.Heartbeat:Connect(function()
                if not autoHarvestRunning or not isAutoFloorActive or isDeathProcessing then
                    if autoHarvestConnection then
                        autoHarvestConnection:Disconnect()
                        autoHarvestConnection = nil
                    end
                    return
                end
                local hasTarget = currentTargetMob2 and currentTargetMob2:FindFirstChild("MODEL") and currentTargetMob2.MODEL:FindFirstChild("HumanoidRootPart")
                if hasTarget then
                    local hp = currentTargetMob2:GetAttribute("HP")
                    hasTarget = hp and hp > 0
                end
                if hasTarget then
                    pressKey(Enum.KeyCode.F)
                    wait(0.2)
                else
                    pressKey(Enum.KeyCode.F)
                    wait(1)
                    pressKey(Enum.KeyCode.E)
                    wait(2)
                end
            end)
            StarterGui:SetCore("SendNotification", {
                Title = "Auto Harvest",
                Text = "Auto Harvest resumed with Auto Floor!",
                Duration = 5
            })
        end
    end
    if isSuppliesAutofarming then
        wait(1)
        enableWallhack()
        startSuppliesAutofarm()
    end
    if isTeleportStoryActive then
        wait(1)
        startTeleportStory()
    end
    if wallhackActive and not isSuppliesAutofarming then
        enableWallhack()
    end
end)

-- Start monitoring the death indicator
monitorDeathIndicator()

-- Notify user that the script has loaded successfully
TeleportGUILibrary.createNotification("Script loaded successfully!", "success")